/*
1.use `#pragma metal_compute_shader` to flag this shader as a native metal 
  compute shader. We use special compile process for this kind of shader.
2.user header files are not supported(coming soon), we should include these files manually.
3.use computeMain as the kernel name, and we support only 1 compute kernel in one file a.t.m
*/

/*
    This shader is adapted from Apple's ForwardPlusWithTileShading demo.
*/
#pragma kernel computeMain
#pragma metal_compute_shader

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

#define AAPLMaxLightsPerTile 64

// master image block definition
struct GBufferData {
    half4 GBuffer0 [[ user(GBuffer0), raster_order_group(0) ]];
    half4 GBuffer1 [[ user(GBuffer1), raster_order_group(0) ]];
    half4 GBuffer2 [[ user(GBuffer2), raster_order_group(0) ]];
    float Depth [[ user(Depth), raster_order_group(0) ]];
};

// view image block definition
// I have tested and verified that this also works in tile shader!
// Good for bandwidth, or not?
// Last time I tested it in pixel shader and it really saves xx ms,
// However after I tested in ForwardPlusWithTileShading, this has no effect at all
struct GBufferDataDepthSlice {
    float Depth [[ user(Depth), raster_order_group(0) ]];
};

// TODO: This struct can be truncated further to save bandwidth?
struct PunctualLightData {
    float3 wsPos;
    float radius;
    float4 color;
    float4 attenuation;
    float3 spotDirection;
    int lightIndex;
};

struct uniforms {
    int numLights; // total number of `PunctualLightData`
    vector_float4 _ZBufferParams;   // unproject to view depth
    vector_float4 screenToViewSpace;    // unproject to view space xy
    float4x4 unity_MatrixV; // convert light position to world space to view space
};

// Per-tile data computed by our culling kernel
struct TileData
{
    atomic_int numLights;
    float minDepth;
    float maxDepth;
};

// Z buffer to linear depth.
// Does NOT correctly handle oblique view frustums.
// Does NOT work with orthographic projection.
// zBufferParam = { (f-n)/n, 1, (f-n)/n*f, 1/f }
static float LinearEyeDepth(float depth, float4 &zBufferParam)
{
    return 1.0 / (zBufferParam.z * depth + zBufferParam.w);
}

// Unprojects x and y in screen space to view space if the screen x and y are at screen z = 1.0
static float2 screen_to_view_at_z1(vector_float4 &screenToViewSpace, ushort2 screen)
{
    return float2(screen) * screenToViewSpace.xy + screenToViewSpace.zw;
}

kernel void computeMain(
    imageblock<GBufferDataDepthSlice, imageblock_layout_explicit> imageBlock,
    constant PunctualLightData *_lightData       [[ buffer(0) ]],
    constant AAPLUniforms &uniforms             [[ buffer(1) ]],
    threadgroup int *visible_lights       [[ threadgroup(0) ]],
    threadgroup TileData *tile_data       [[ threadgroup(1) ]],
    ushort2 thread_local_position         [[ thread_position_in_threadgroup ]],
    ushort2 threadgroup_size              [[ threads_per_threadgroup ]],
    ushort2 threadgroup_id                [[ threadgroup_position_in_grid ]],
    uint thread_linear_id                 [[ thread_index_in_threadgroup]],
    uint simd_lane_id                     [[ thread_index_in_quadgroup ]]
)
{
    // skip 4-byte counter
    constant PunctualLightData* lightData = reinterpret_cast<constant PunctualLightData*>(reinterpret_cast<const device uint*>(_lightData) + 1);
    GBufferDataDepthSlice f = imageBlock.read(thread_local_position);

    uint threadgroup_linear_size = threadgroup_size.x * threadgroup_size.y;

    // When the thread group begins...
    if (thread_linear_id == 0)
    {
        // Set our counter for the number of lights in this tile to 0
        atomic_store_explicit(&tile_data->numLights, 0, memory_order_relaxed);

        // Initialize our min and max depth values
        tile_data->minDepth = INFINITY;
        tile_data->maxDepth = 0.0;
    }    

    // Insert a barrier here before we get the min an max depth for the entire tile to enure
    //   that ALL threads in the threadgroup have determined the min and max depth for their quads
    //   first
    threadgroup_barrier(mem_flags::mem_threadgroup);
    
    // Determine the min and max depth in our quad group.  Note that quad groups execute in step, so
    //   we can determine the min and max depth value in the quad group without needing to use barriers

    float minDepth = 1.0f - f.Depth; // reverse-z
    minDepth = min(minDepth, quad_shuffle_xor(minDepth, 2));
    minDepth = min(minDepth, quad_shuffle_xor(minDepth, 1));

    float maxDepth = 1.0f - f.Depth; // reverse-z
    maxDepth = max(maxDepth, quad_shuffle_xor(maxDepth, 2));
    maxDepth = max(maxDepth, quad_shuffle_xor(maxDepth, 1));

    // For one quad lane...
    if (simd_lane_id == 0)
    {
        // ...compare vs everyother depth value in the threadgroups and set it if min depth value
        //   (or max depth value) of the quad  is the min depth value (or max depth value) of the
        //   entire tile
        atomic_fetch_min_explicit((threadgroup atomic_uint *)&tile_data->minDepth, as_type<uint>(minDepth), memory_order_relaxed);
        atomic_fetch_max_explicit((threadgroup atomic_uint *)&tile_data->maxDepth, as_type<uint>(maxDepth), memory_order_relaxed);
    }

    // Ensure our fetch of min/max values of all quad groups withing the thread group hava finished
    //   execution before using the values to test against light volumes
    threadgroup_barrier(mem_flags::mem_threadgroup);  

    // Unproject depth from screens space to view/eye space where we do the culling
    float minDepthView = LinearEyeDepth(1.0f - tile_data->minDepth, uniforms._ZBufferParams);
    float maxDepthView = LinearEyeDepth(1.0f - tile_data->maxDepth, uniforms._ZBufferParams);

    float2 minTileViewAtZ1 = screen_to_view_at_z1(uniforms.screenToViewSpace, threadgroup_id * threadgroup_size);
    float2 maxTileViewAtZ1 = screen_to_view_at_z1(uniforms.screenToViewSpace, (threadgroup_id + 1) * threadgroup_size);    

    // Calculate normals of the tile bounding planes
    // TODO: We can save 2 normalize call here
    float3 tile_plane_normal[6];
    tile_plane_normal[0] = normalize(float3(1.0, 0.0, -maxTileViewAtZ1.x)); // right
    tile_plane_normal[1] = normalize(float3(0.0, 1.0, -minTileViewAtZ1.y)); // top
    tile_plane_normal[2] = normalize(float3(-1.0, 0.0, minTileViewAtZ1.x)); // left
    tile_plane_normal[3] = normalize(float3(0.0, -1.0, maxTileViewAtZ1.y)); // bottom
    tile_plane_normal[4] = float3(0.0, 0.0, -1.0); // near
    tile_plane_normal[5] = float3(0.0, 0.0, 1.0);  // far

    // Calculate culling offsets
    float tile_plane_offset[6];

    // Top/Bottom/Right/Left offsets are 0 since center of eye space coordinate system belongs to
    //   all these planes
    tile_plane_offset[0] = 0.0f;
    tile_plane_offset[1] = 0.0f;
    tile_plane_offset[2] = 0.0f;
    tile_plane_offset[3] = 0.0f;

    // Use the min and max depth so we cull light volumes that are completely in front of the nearest
    //   geometry in the tile or completely in back of the furthes geometry in the tile
    tile_plane_offset[4] = -minDepthView;
    tile_plane_offset[5] = maxDepthView;

    // Create list of visible lights inside threadgroup memory
    for (uint baseLightId = 0; baseLightId < uniforms.numLights; baseLightId += threadgroup_linear_size)
    {
        uint32_t visible = 1;

        // Light id for current thread and iteration
        uint lightId = baseLightId+thread_linear_id;
        if(lightId > uniforms.numLights-1)
        {
            visible = 0;
            lightId = 0;
        }

        // Get light data
        float4 light_pos_eye_space = (uniforms.unity_MatrixV * float4(_light_positions[lightId].xyz,1));

        // Cull light against all 6 planes
        for(int j = 0; j < 6; j++)
        {
            if(dot(tile_plane_normal[j],light_pos_eye_space.xyz)-tile_plane_offset[j] > light_positions[lightId].w)
            {
                visible = 0; // separating axis found
                break;
            }
        }

        // Perform stream compaction into tile memory

        // If this light is visible...
        if (visible)
        {
            // Increase the count of lights for this tile and get a slot
            int slot = atomic_fetch_add_explicit(&tile_data->numLights, 1, memory_order_relaxed);

            // Insert the lightId into or visibile light list for this tile
            if (slot < AAPLMaxLightsPerTile)
                visible_lights[slot] = (int)lightId;
        }
    }    
}